import { Injectable } from '@nestjs/common';
import { BaseQuery } from './base.query';

export interface Contact {
  id: string; // The numeric ID from DB, returned as string usually by PG driver for bigints, or number. We'll standardise in map.
  uuid: string;
  name: string;
  email: string;
  message: string;
  status: 'new' | 'read' | 'archived';
  createdAt: Date;
  updatedAt?: Date;
}

export interface ContactCreateInput {
  name: string;
  email: string;
  message: string;
}

@Injectable()
export class ContactQuery extends BaseQuery {
  protected getTableName(): string {
    return 'data.contacts';
  }

  protected mapToEntity(row: any): Contact {
    return {
      id: row.id,
      uuid: row.uuid,
      name: row.name,
      email: row.email,
      message: row.message,
      status: row.status,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }

  async create(input: ContactCreateInput): Promise<Contact> {
    const insertData = {
      name: input.name,
      email: input.email,
      message: input.message,
      status: 'new',
      // id and uuid generated by DB
      // created_at generated by DB
    };

    const [row] = await this.knex(this.getTableName())
      .insert(insertData)
      .returning('*');

    return this.mapToEntity(row);
  }

  async findAll(options?: { limit?: number; offset?: number }): Promise<Contact[]> {
    let query = this.knex(this.getTableName()).orderBy('created_at', 'desc');

    if (options?.limit) {
      query = query.limit(options.limit);
    }

    if (options?.offset) {
      query = query.offset(options.offset);
    }

    const rows = await query;
    return this.mapToEntities(rows);
  }

  async findById(id: number | string): Promise<Contact | null> {
    const row = await this.knex(this.getTableName()).where({ id }).first();
    return row ? this.mapToEntity(row) : null;
  }

  async updateStatus(id: number | string, status: 'read' | 'archived'): Promise<Contact | null> {
    const [row] = await this.knex(this.getTableName())
      .where({ id })
      .update({ status })
      .returning('*');
    return row ? this.mapToEntity(row) : null;
  }
}

